[{"title":"Windows CMD常用命令大全","url":"/2023/11/23/windows-cmd-commands.html","content":"Windows CMD常用命令大全   打开CMD命令行：Win + R ，输入 cmd 点击确定   附录：    Windows 命令   1. cd命令   D:                  // 进入d盘F:                  // 进入F盘cd /?               // 获取使用帮助cd \\                // 跳转到当前硬盘的根目录cd C:\\WINDOWS       // 跳转到C盘的WINDOWS文件夹cd /d e:\\software   // 跳转到e盘的software文件夹，注意此处必须加/d参数。否则无法跳转。cd..                // 跳转到上一层目录   2. 查看目录文件   dir            // 查看当前目录下的文件，类似于linux下的lspython /?      // 获取使用帮助   3. 创建目录和删除目录   md [folder]    // 创建目录（文件夹）rd [folder]    // 删除目录（文件夹）   4. 清除屏幕   cls    // 类似于linux下的clear   5. 复制文件   copy [path\\filename] [path\\filename]    // 把一个文件拷贝到另一个地方。   6. 移动文件   move [path\\filename] [path\\filename]    // 把一个文件移动（就是剪切+复制）到另一个地方。   7. 删除文件   del [filename]        // 这个是专门删除文件的，不能删除文件夹   8. ping   ping [ip]   // 用来测试网络是否畅通，例如 ping www.baidu.com   9. netstat 查看网络连接状态   显示协议统计信息和当前 TCP/IP 网络连接。该命令可以查看当前机器建立的所有网络链接状态，以及对应哪个进程。   netstat -help                        // 获取命令行使用帮助信息netstat -ano                         // 查看网络连接、状态以及对应的进程idnetstat -aon|findstr &quot;8080&quot;          // 查看被占用端口对应的 PID   10. tasklist   命令显示计算机上当前正在运行的进程列表。   tasklist                              // 获取 PID 进程列表tasklist|findstr &quot;8080&quot;               // 查看指定 PID 的进程tasklist /fi &quot;IMAGENAME eq nginx.exe&quot; // 查找所有映像名称为nginx.exe的进程   11. taskkill   杀进程任务及进程号   taskkill [/S system [/U username [/P [password]]]] { [/FI filter] [/PID processid | /IM imagename] } [/F] [/T]  // 命令规则/S system 指定要连接到的远程系统。/U [domain\\]username 指定应该在哪个用户上下文。/P [password] 为提供的用户上下文指定密码。如果忽略，提示输入。/F 指定要强行终止的进程。/FI filter 指定筛选进或筛选出查询的的任务。/PID processid 指定要终止的进程的PID。/IM imagename 指定要终止的进程的映像名称。通配符 &#39;*&#39;可用来指定所有映像名。/T 终止指定的进程和任何由此启动的子进程。/? 显示帮助/用法。   示例   taskkill /PID 8080        // 杀死 PID 为 8080 的进程taskkill /T /F /PID 8080  // 强制（/F参数）杀死 PID 为 8080 的所有进程包括子进程（/T参数）taskkill /IM nginx.exe // 杀死所有映像名称为nginx.exe的进程   13. tracert   tracert也被称为Windows路由跟踪实用程序，在命令提示符（cmd）中使用tracert命令可以用于确定IP数据包访问目标时所选择的路径。   tracert /? 获取使用帮助   14. 辅助符号 ‘|’   “|”cmd命令中|代表前一个的输出代表后一个的输入   netstat -ano|find &quot;192.168.1.10&quot;  // 查找特定ip的网络连接及进程号   15 重定向输出符号&gt; &gt;&gt;   将原本输出到命令窗口的内容，转存到文件中，如jstack 12912 &gt;d:/s.txt 打印线程到指定文件   cmd &gt; 重定向输出并覆盖源文件。   echo hello &gt;c:\\1.txt   // 1.txt的文件内容先被清空，然后写入hello。   cmd &gt;&gt;重定向输出追加到文件末尾   echo hello &gt;&gt;c:\\1.txt  // 在1.txt文件末尾加上hello   16. 重定向输入符号&lt; &lt;&lt;   cmd &lt; file     // 使cmd命令从file读入cmd &lt;&lt; text    // 从命令行读取输入，直到一个与text相同的行结束。// 除非使用引号把输入括起来，此模式将对输入内容进行shell变量替换。// 如果使用 &lt;&lt;- ，则会忽略接下来输入行首的tab，结束行也可以是一堆tab再加上一个与text相同的内容，可以参考后面的例子。cmd &lt;&lt;&lt; word   // 把word（而不是文件word）和后面的换行作为输入提供给cmd。cmd &lt;&gt; file    // 以读写模式把文件file重定向到输入，文件file不会被破坏。仅当应用程序利用了这一特性时，它才是有意义的。cmd &gt;| file    // 功能同&gt;，但即便在设置了noclobber时也会覆盖file文件，注意用的是|而非一些书中说的!，目前仅在csh中仍沿用&gt;!实现这一功能。","categories":["note"]},{"title":"运维的未来是平台工程","url":"/2023/07/19/platform-engineering.html","content":"","categories":["reprint"]},{"title":"软件吃软件，编程工作会越来越多吗？","url":"/2023/07/07/will-programmers-increase.html","content":"","categories":["reprint"]},{"title":"大盘鸡","url":"/2022/08/16/big-plate-chicken.html","content":"食材用料   食材   数量   鸡   一只   土豆   两个   青椒   两个   油   适量   白糖   适量   葱   适量   姜   适量   蒜   适量   辣椒   适量   花椒   适量   八角   适量   香叶   适量   桂皮   适量   盐   适量   生抽   适量   老抽   适量   辣椒油   适量   料酒   适量   做法步骤   图片   步骤   1.    准备食材   2.    准备调料：蒜、姜、蒜、辣椒、花椒、八角、香叶、桂皮   3.    鸡块焯水，放入姜片、料酒   4.    土豆切滚刀块   5.    鸡块去除浮沫后捞出   6.    放油大火，放入白糖或者冰糖炒化   7.    放入鸡块翻炒，炒出香味   8.    放入调料翻炒   9.    放入盐、生抽、老抽、辣椒油、料酒翻炒均匀   10.    放入土豆翻炒，然后加入水没过土豆，盖上锅盖   11.    煮到一半放入青椒，大火收汁   12.    装盘","categories":["cookbook"]},{"title":"Language Tags (BCP 47)","url":"/2022/04/10/language-tags.html","content":"Language Tag   Language   Region   Description   ar-SA   Arabic   Saudi Arabia   Arabic (Saudi Arabia)   bn-BD   Bangla   Bangladesh   Bangla (Bangladesh)   bn-IN   Bangla   India   Bangla (India)   cs-CZ   Czech   Czech Republic   Czech (Czech Republic)   da-DK   Danish   Denmark   Danish (Denmark)   de-AT   German   Austria   Austrian German   de-CH   German   Switzerland   &quot;Swiss&quot; German   de-DE   German   Germany   Standard German (as spoken in Germany)   el-GR   Greek   Greece   Modern Greek   en-AU   English   Australia   Australian English   en-CA   English   Canada   Canadian English   en-GB   English   United Kingdom   British English   en-IE   English   Ireland   Irish English   en-IN   English   India   Indian English   en-NZ   English   New Zealand   New Zealand English   en-US   English   United States   US English   en-ZA   English   South Africa   English (South Africa)   es-AR   Spanish   Argentina   Argentine Spanish   es-CL   Spanish   Chile   Chilean Spanish   es-CO   Spanish   Columbia   Colombian Spanish   es-ES   Spanish   Spain   Castilian Spanish (as spoken in Central-Northern Spain)   es-MX   Spanish   Mexico   Mexican Spanish   es-US   Spanish   United States   American Spanish   fi-FI   Finnish   Finland   Finnish (Finland)   fr-BE   French   Belgium   Belgian French   fr-CA   French   Canada   Canadian French   fr-CH   French   Switzerland   &quot;Swiss&quot; French   fr-FR   French   France   Standard French (especially in France)   he-IL   Hebrew   Israel   Hebrew (Israel)   hi-IN   Hindi   India   Hindi (India)   hu-HU   Hungarian   Hungary   Hungarian (Hungary)   id-ID   Indonesian   Indonesia   Indonesian (Indonesia)   it-CH   Italian   Switzerland   &quot;Swiss&quot; Italian   it-IT   Italian   Italy   Standard Italian (as spoken in Italy)   jp-JP   Japanese   Japan   Japanese (Japan)   ko-KR   Korean   Republic of Korea   Korean (Republic of Korea)   nl-BE   Dutch   Belgium   Belgian Dutch   nl-NL   Dutch   The Netherlands   Standard Dutch (as spoken in The Netherlands)   no-NO   Norwegian   Norway   Norwegian (Norway)   pl-PL   Polish   Poland   Polish (Poland)   pt-BR   Portugese   Brazil   Brazilian Portuguese   pt-PT   Portugese   Portugal   European Portuguese (as written and spoken in Portugal)   ro-RO   Romanian   Romania   Romanian (Romania)   ru-RU   Russian   Russian Federation   Russian (Russian Federation)   sk-SK   Slovak   Slovakia   Slovak (Slovakia)   sv-SE   Swedish   Sweden   Swedish (Sweden)   ta-IN   Tamil   India   Indian Tamil   ta-LK   Tamil   Sri Lanka   Sri Lankan Tamil   th-TH   Thai   Thailand   Thai (Thailand)   tr-TR   Turkish   Turkey   Turkish (Turkey)   zh-CN   Chinese   China   Mainland China, simplified characters   zh-HK   Chinese   Hond Kong   Hong Kong, traditional characters   zh-TW   Chinese   Taiwan   Taiwan, traditional characters","categories":["note"]},{"title":"杏鲍菇炒肉","url":"/2021/12/24/fried-meat-with-pleurotus-eryngii.html","content":"食材用料   食材   数量   杏鲍菇   250克   鸡胸肉   半块   油   适量   葱   适量   姜   适量   蒜   适量   辣椒   适量   花椒   适量   盐   适量   冰糖   适量   生抽   适量   老抽   少量   耗油   适量   十三香   适量   做法步骤   图片   步骤   1.    准备食材   2.    准备调料：葱姜蒜、辣椒、花椒   3.    杏鲍菇洗净切片   4.    肉切片，捏掉水   5.    放油中火，放调料爆香   6.    放肉片炒熟   7.    放入杏鲍菇片，大火翻炒变软   8.    放入盐、冰糖、生抽、老抽、十三香翻炒   9.    收锅   10.    装盘","categories":["cookbook"]},{"title":"NPM如何查看更新包版本","url":"/2021/10/22/npm-check-update.html","content":"先查询有哪些包有更新   $ npm outdated   如查看xxx包的最新版本信息   $ npm view xxx versions  or$ npm info xxx   使用npm安装指定版本的包   $ npm i xxx@1.11.1 --save-dev   使用npm升级指定版本的包   $ npm update xxx --save-dev   安装xxx最新版本的包   $ npm i xxx@latest --save-dev   使用npm查看已安装的包列表   $ npm list   使用npm查看已安装某一指定包的版本信息   $ npm list xxx   使用npm-check查看更新包   $ npm install -g npm-check  # 先全局安装 npm-check$ npm-check -u              # 查询当前项目下的包更新$ npm-check -u -g           # 查询全局安装的包更新   会列出所有的更新，上下键控制，空格选中或取消选中，选好了以后按回车就行了。","categories":["note"]},{"title":"香菇炖羊排","url":"/2021/10/19/stewed-lamb-chop-with-mushroom.html","content":"食材用料   食材   数量   羊排   6个   香菇   300克   油   多量   盐   适量   辣椒   适量   花椒   适量   八角   适量   孜然   适量   羊排必须焯水去血沫，不然腥味重。   做法步骤   图片   步骤   1.    准备食材   2.    调料盘：辣椒、花椒、八角、孜然   3.    羊排加水放血   4.    温水焯水捞出   5.    放入调料中火翻炒羊排   6.    加水，放入切好的香菇，放入盐   7.    中火炖煮30分钟   8.    装盘","categories":["cookbook"]},{"title":"青椒炒肉","url":"/2021/09/05/green-pepper-parch-meat.html","content":"食材用料   食材   数量   青椒   300克   猪肉   120克   油   适量   蒜   适量   盐   适量   生抽   适量   老抽   少量   料酒   适量   肉嫩青椒好吃关键：不能大火，全程中火。   做法步骤   图片   步骤   1.    准备食材   2.    准备调料：蒜、辣椒   3.    青椒切成丝   4.    肉切丝，捏掉水，放入淀粉、生抽、料酒   5.    搅拌成粘稠状腌一下   6.    放油中火，放调料爆香   7.    放肉丝炒熟   8.    放入青椒翻炒均匀   9.    放入盐、老抽翻炒   10.    收锅   11.    装盘","categories":["cookbook"]},{"title":"番茄香肠炒鸡蛋","url":"/2021/06/14/scrambled-egg-with-tomato-sausage.html","content":"食材用料   食材   数量   番茄   250克   鸡蛋   两个   香肠   60克   油   适量   干辣椒   适量   盐   适量   冰糖   适量   做法步骤   图片   步骤   1.    准备食材   2.    番茄底部切掉，为了煮开的时候更好裂皮   3.    开水煮到番茄表面裂皮   4.    番茄剥皮   5.    番茄切成小块   6.    打入鸡蛋、葱花搅拌   7.    香肠切片和辣椒装在一起   8.    热锅热油，油冒烟放入鸡蛋液   9.    放入香肠辣椒翻炒均匀   10.    放入番茄块翻炒均匀，放入盐（番茄块用锅铲摁烂）   11.    收锅   12.    装盘","categories":["cookbook"]},{"title":"JavaScript 注释规范","url":"/2021/04/28/javascript-document-convertions.html","content":"Type 语法   类型名   语法示例   描述   Symbol name   {string}, {myNamespace.MyClass}   指定符号的名称。   Multiple types   {number|boolean}   这意味着值可能是几种类型中的一种，用&quot;|&quot;分隔类型的完整列表。   Arrays   {string[]}, {MyClass[]}   表达式   string[]   表示字符串数组，    表达式   {MyClass[]}   标识具有MyClass实例的数组   Objects   {a: number, b: string, c}     // or     {object} myObj     {number} myObj.a     {string} myObj.b     {any} myObj.c   对象“MyObj”中具有属性 &#39;a&#39; (一个数字) &#39;b&#39; (一个字符串) 和 &#39;c&#39; (任何类型)，    对于具有一组已知的属性的对象，    你可以使用 Closure Compiler 语法文档化标注的类型。    你也可以分别描述每个属性，    这使你能够提供有关每个属性的更多详细信息。   Nullable type   {?number}   指明类型为指定的类型，或者为null。   Non-nullable type   {!number}   指明类型为指定的类型，但是绝对不会是null。   Variable number of that type   @param {...number} num   表示该函数接受可变数量的参数，并指定一个类型的参数。   Optional parameter   @param {number} [foo=1]   指示参数是可选的, 你还可以指明参数的默认值。   Callbacks   @callback myCallback     @param {number} x - ...   使用@callback标签指明一个回调。    和@typedef标签是相同的，    不同之处在于回调的类型始终是&quot;function&quot;。   Type definitions   @typedef {object} PropertiesHash     @property {string} id     @property {string} name     @property {number} age   你可以使用@typedef标签记录复杂类型。   常用注释关键字   注释名   别名   描述   @param   @argument, @arg   记录传递给一个函数的参数。   @return   @returns   记录一个函数的返回值。   @method   @function, @func   描述一个函数或方法。   @typedef   记录一个自定义的类型。   @property   @prop   记录一个对象的属性。   @callback   描述一个回调函数。   @author   指定项目的作者。   @copyright   描述一个文件的版权信息。   @description   描述一个标识。   @param   记录传递给一个函数的参数。   别名： @arg，@argument   /*** @param {string} somebody - Somebody's name.*/function sayHello(somebody) {alert('Hello ' + somebody);}   如果参数是一个对象，有特定的属性：   /*** Assign the project to an employee.* @param {object} employee            - The employee who is responsible for the project.* @param {string} employee.name       - The name of the employee.* @param {string} employee.department - The employee's department.*/Project.prototype.assign = function(employee) { ... };   如果参数的属性值在数组中：   /*** Assign the project to a list of employees.* @param {object[]} employees            - The employees who are responsible for the project.* @param {string} employees[].name       - The name of an employee.* @param {string} employees[].department - The employee's department.*/Project.prototype.assign = function(employees) { ... };   一个可选参数和默认值：   /*** @param {string} [somebody=John Doe] - Somebody's name.*/function sayHello(somebody) {if (!somebody) {  somebody = 'John Doe';}alert('Hello ' + somebody);}   允许一个类型或另一个类型：   /*** @param {string|string[]} [somebody=John Doe] - Somebody's name, or an array of names.*/function sayHello(somebody) {if (!somebody) {  somebody = 'John Doe';} else if (Array.isArray(somebody)) {  somebody = somebody.join(', ');}alert('Hello ' + somebody);}   参数接受一个回调函数：   /*** @param {requestCallback} cb*//*** @callback requestCallback* @param {number} responseCode* @param {string} responseMessage*/function doSomethingAsynchronously(cb) { ... }   @return   记录一个函数的返回值。   别名： @returns   /*** Returns the sum of a and b* @param {number} a* @param {number} b* @param {boolean} retArr If set to true, the function will return an array* @return {number|array} Sum of a and b or an array that contains a, b and the sum of a and b.*/function sum(a, b, retArr) {if (retArr) {  return [a, b, a + b];}return a + b;}   @method   描述一个函数或方法。   别名： @function, @func   /*** Returns the sum of a and b* @method sum* @param {number} a* @param {number} b* @return {number} Sum of a and b or an array that contains a, b and the sum of a and b.*/function sum(a, b) {return a + b;}   @typedef   记录一个自定义的类型。   /*** The complete Triforce, or one or more components of the Triforce.* @typedef {Object} WishGranter~Triforce* @property {boolean} hasCourage - Indicates whether the Courage component is present.* @property {boolean} hasPower   - Indicates whether the Power component is present.* @property {boolean} hasWisdom  - Indicates whether the Wisdom component is present.*//*** A class for granting wishes, powered by the Triforce.* @class* @param {...WishGranter~Triforce} triforce - One to three {@link WishGranter~Triforce} objects* containing all three components of the Triforce.*/function WishGranter() {}   @property   记录一个对象的属性。   /*** @namespace* @property {object}  defaults               - The default values for parties.* @property {number}  defaults.players       - The default number of players.* @property {string}  defaults.level         - The default level for the party.* @property {object}  defaults.treasure      - The default treasure.* @property {number}  defaults.treasure.gold - How much gold the party starts with.*/var config = {defaults: {  players: 1,  level: 'beginner',  treasure: {    gold: 0  }}};   @callback   描述一个回调函数。   /*** @class*/function Requester() {}   /**   Send a request.   @param {Requester~requestCallback} cb - The callback that handles the response.   /Requester.prototype.send = function(cb) {// code};   /**   This callback is displayed as part of the Requester class.   @callback Requester~requestCallback   @param {number} responseCode   @param {string} responseMessage   /   @author   指定项目的作者。   /*** @author Zane Liu &lt;liuzane@example.com&gt;*/function MyClass() {}   @copyright   描述一些版权信息。   /*** @file This is my cool script.* @copyright Zane Liu 2021*/   @description   描述一个标识。   /*** @param {number} a* @param {number} b* @returns {number}* @description Add two numbers.*/function add(a, b) {return a + b;}","categories":["javascript"]},{"title":"香菇炒肉","url":"/2021/04/05/mushroom-fried-meat.html","content":"食材用料   食材   数量   香菇   250克   鸡胸肉   半块   青椒   一个   油   少量   蒜   适量   葱   适量   辣椒   适量   花椒   适量   盐   适量   老抽   适量   十三香   适量   豆瓣酱   适量   做法步骤   图片   步骤   1.    准备食材   2.    准备调料：蒜切片、辣椒、花椒、葱花   3.    蘑菇切片焯水装盘   4.    肉切片，捏掉水   5.    青椒切成条   6.    放油放入调料爆香   7.    中火放入肉炒熟   8.    放入青椒、蘑菇大火翻炒   9.    放入盐、老抽、十三香、豆瓣酱   10.    大火翻炒几下   11.    出锅   12.    装盘","categories":["cookbook"]},{"title":"ScrollContainer Component","url":"/2020/12/30/scroll-container.html","content":"滚动容器组件   Plugin   Name   Link   prop-types   https://github.com/facebook/prop-types   Usage   null   ScrollContainer   // 基础模块import React, { Component } from 'react';import PropTypes from 'prop-types';   class ScrollContainer extends Component {  static propTypes = {    className: PropTypes.string,    style: PropTypes.object,    tagName: PropTypes.string,    scrollBottomDistance: PropTypes.oneOfType([ PropTypes.number, PropTypes.string ]),    onScrollBottom: PropTypes.func,    children: PropTypes.node,  }     static defaultProps = {    tagName: &#39;div&#39;,    scrollBottomDistance: 100,    onScrollBottom: () =&gt; {},  }     constructor(props) {    super(props);    this.scrollBottom = false;  }     // 监听content是否滑动到底部  onScroll = (e) =&gt; {    const { onScrollBottom } = this.props;    const target = e.currentTarget;    const scrollHeight = target.scrollHeight;    const scrollTop = target.scrollTop;    const clientHeight = target.clientHeight;    const scrollBottomDistance = parseInt(this.props.scrollBottomDistance);   if (scrollHeight - clientHeight &gt; (scrollTop + scrollBottomDistance)) {  this.scrollBottom = false;}if (!this.scrollBottom &amp;&amp; (scrollHeight - clientHeight &lt;= (scrollTop + scrollBottomDistance))) {  //滚动条滚到最底部  this.scrollBottom = true;  onScrollBottom();}     }     render() {    const { className, style, children } = this.props;    return (      &lt;this.props.tagName         className={className}        style={style}        onScroll={this.onScroll}      &gt;        {children}      &lt;/this.props.tagName&gt;    );  }}   export default ScrollContainer;```","categories":["react"]},{"title":"Screenshot Component","url":"/2020/12/30/screenshot.html","content":"截屏组件   Plugin   Name   Link   prop-types   https://github.com/facebook/prop-types   html2canvas   http://html2canvas.hertzen.com   Usage   null   Screenshot.jsx   import React, { Component } from 'react';import PropTypes from 'prop-types';import html2canvas from 'html2canvas';   import &#39;./Screenshot.css&#39;;   class Screenshot extends Component {  static propTypes = {    options: PropTypes.object,    className: PropTypes.string,    style: PropTypes.object,    children: PropTypes.node,    callback: PropTypes.func,    onRef: PropTypes.func,  }     static defaultProps = {    options: {},    callback: () =&gt; {},    onRef: () =&gt; {},  }     constructor(props) {    super(props);    this.Element = React.createRef();   Screenshot.screenshot = this.screenshot.bind(this);     }     componentDidMount() {    this.props.onRef(this.Element);  }     // 截图  screenshot = () =&gt; {    const { callback } = this.props;    const Element = this.Element.current;    const options = {      logging: false,      scale: 2,      scrollX: 0,      scrollY: 0,      backgroundColor: null,      useCORS: true,    };    // Element.classList.add(&#39;screenshot&#39;);    html2canvas(Element, options).then((canvas) =&gt; {      // Element.classList.remove(&#39;screenshot&#39;);      callback(canvas);    });  }     render() {    const { className, style, children } = this.props;    return (         {children}       );  }}   export default Screenshot;   * Screenshot.css```css.screenshot {  position: fixed !important;  top: 0 !important;  left: 0 !important;}","categories":["react"]},{"title":"香辣虾","url":"/2020/12/27/fried-shrimp-with-chilli.html","content":"食材用料   食材   数量   基围虾   10个   油   适量   葱   适量   蒜   适量   姜   适量   辣椒   适量   香叶   适量   盐   适量   清水   半碗   生抽   适量   做法步骤   图片   步骤   1.    准备食材   2.    葱切段，姜切撕，蒜切末装盘   3.    调料汁：清水、生抽、盐、香叶   4.    虾洗净，挑去虾线   5.    热锅热油，下虾，煎至两面成漂亮的红色出虾油后，盛出虾（用锅铲轻轻压一压虾，红油出的多）   6.    把葱和姜放入虾油锅中爆香   7.    放入煎好的虾，倒入调料汁   8.    大火收汁   9.    装盘","categories":["cookbook"]},{"title":"ClickOutside Component","url":"/2020/12/25/click-outside.html","content":"点击到元素外面组件   Plugin   Name   Link   prop-types   https://github.com/facebook/prop-types   immutable   https://github.com/immutable-js/immutable-js   Usage   null   ClickOutside.jsx   // 基础模块import React, { Component } from 'react';import PropTypes from 'prop-types';   // 第三方模块import { fromJS, is } from &#39;immutable&#39;;   class ClickOutside extends Component {  static propTypes = {    tag: PropTypes.string.isRequired,    children: PropTypes.element,    onOutside: PropTypes.func,  };     static defaultProps = {    onOutside: () =&gt; {},  };     constructor(props) {    super(props);    this.Tag = React.createRef();  }     componentDidMount() {    document.addEventListener(&#39;click&#39;, this.isOutside);  }     componentWillunmount() {    document.removeEventListener(&#39;click&#39;, this.isOutside);  }     isOutside = event =&gt; {    let [ isChild, node ] = [ false, event.target ];    while (node &amp;&amp; node.id !== &#39;root&#39;) {      if (is(fromJS(node), fromJS(this.refs.tag))) {        isChild = true;        break;      }      node = node.parentNode;    }    if (!isChild) {      this.props.onOutside();    }  }     render() {    const { tag, children, ...restProps } = this.props;    return (      &lt;this.props.tag        ref={this.Tag}        onClick={ this.isOutside }        {...restProps}      &gt;        { children }      &lt;/this.props.tag&gt;    );  }}   export default ClickOutside;```","categories":["react"]},{"title":"Validate Component","url":"/2020/12/25/validate.html","content":"自定义验证组件   Plugin   Name   Link   prop-types   https://github.com/facebook/prop-types   immutable   https://github.com/immutable-js/immutable-js   lodash   https://www.lodashjs.com   Usage   class Desktop extends PureComponent {constructor() {  super();  this.state = {    model: {      name: '',      phone: '',    },    rules: {      name: {        required: true,        message: 'Please type name',      },      phone: [        {          required: true,          message: 'Please type phone',        },        {          validator(rule, value, callback) {            console.log('rule', rule);            console.log('value', value);            if (!/^1\\d{10}$/.test(value)) {              callback('Please type the correct phone, inside');            } else {              callback();            }          },          message: 'Please type the correct phone, outside',        }      ]    }  };}onSetValue = (key, e) =&gt; {  const value = e.target.value;  const model = _.cloneDeep(this.state.model);  model[key] = value;  this.setState({ model });}handleValidate = () =&gt; {  Validate.validate((error, model) =&gt; {    console.log('error', error);    console.log('model', model);  });}render() {  const { model, rules } = this.state;  return (    &lt;LayContainer&gt;      &lt;Validate model={model} rules={rules}&gt;        {          (messages) =&gt; (            &lt;div className=\"validate-wrap\"&gt;              &lt;div className=\"validate-row\"&gt;                &lt;Input value={model.name} placeholder=\"Please type name\" onChange={this.onSetValue.bind(this, 'name')}/&gt;                &lt;p&gt;{messages.name}&lt;/p&gt;              &lt;/div&gt;              &lt;div className=\"validate-row\"&gt;                &lt;Input value={model.phone} placeholder=\"Please type phone\" onChange={this.onSetValue.bind(this, 'phone')}/&gt;                &lt;p&gt;{messages.phone}&lt;/p&gt;              &lt;/div&gt;              &lt;Button onClick={this.handleValidate}&gt;验证&lt;/Button&gt;            &lt;/div&gt;          )        }      &lt;/Validate&gt;    &lt;/LayContainer&gt;  );}}   Validate.jsx   // 基础模块import { Component } from 'react';import PropTypes from 'prop-types';   // 第三方模块import { fromJS, is } from &#39;immutable&#39;;import _ from &#39;lodash&#39;;   class Validate extends Component {  static propTypes = {    model: PropTypes.object,    rules: PropTypes.object,    children: PropTypes.func,  };     constructor(props) {    super(props);    this.state = {      messages: {},      originalModel: {},      isValidated: {},    };    Validate.validate = this.validate;  }     // 初始化设置原始model数据  componentWillMount() {    const { model } = this.props;    this.setState({ originalModel: model });  }     // 如果更新了 model 就获取 messages  componentWillReceiveProps(nextProps) {    if (!is(fromJS(this.props.model), fromJS(nextProps.model))) {      const messages = this.getValidateMessages(nextProps.model);      this.setState({ messages });    }  }     shouldComponentUpdate (nextProps, nextState) {    return !is(fromJS(this.props), fromJS(nextProps)) || !is(fromJS(this.state), fromJS(nextState));  }     // 验证规则项  validateRuleItem = (rule, value) =&gt; {    if (rule.required &amp;&amp; !value) {      return rule.message;    }   if (rule.validator) {  let message;  const callback = errorMsg =&gt; {    message = errorMsg || rule.message;  };  rule.validator(rule, value, callback);  return message;}     }     // 获取验证错误信息  getValidateMessages = (model, isValidate) =&gt; {    const messages = {};    const { rules } = this.props;    const { originalModel, isValidated } = this.state;   for (const key in rules) {  if (isValidate || (model[key] !== undefined &amp;&amp; (model[key] !== originalModel[key] || isValidated[key]))) {    // 计算 key 更新次数    isValidated[key] = true;    // 如果规则项是数组    if (_.isArray(rules[key])) {      for (let i = 0; i &lt; rules[key].length; i++) {        const message = this.validateRuleItem(rules[key][i], model[key]);        if (message) {          messages[key] = message;          break;        }      }      continue;    }    // 如果规则项是对象    if (_.isPlainObject(rules[key])) {      const message = this.validateRuleItem(rules[key], model[key]);      if (message) messages[key] = message;      continue;    }  }}this.setState({ countModel: _.cloneDeep(isValidated) });return messages;     }     // 外部调用验证方法  validate = (callback) =&gt; {    const { model } = this.props;    const messages = this.getValidateMessages(model, true);    const error = Object.keys(messages).length &gt; 0 ? messages : null;    this.setState({ messages });    callback(error, model);  }     render () {    const { children } = this.props;    const { messages } = this.state;   return children(messages);     }}   export default Validate;```","categories":["react"]},{"title":"localStorage","url":"/2020/12/10/local-storage.html","content":"setStorage(key, data, hours)   设置localStorage```javascript/**   @method setStorage   @param {string} key   @param {any} data   @param {number} hours   @return {boolean}   /function setStorage(key, data, hours) { let expires;    if (!key || !data) {   console.error(&#39;[localStorage Error]: Key and Data is a must parameter&#39;);   return false; }    expires = hours ? new Date().getTime() + 1000 * 60 * 60 * hours : new Date(0).getTime(); localStorage.setItem(key, JSON.stringify({ data, expires }));    return true;}   getStorage(key)   获取localStorage```javascript/**   @method getStorage   @param {string} key   @return {boolean|null}   /function getStorage(key) { let data, nowTime = new Date().getTime();    if (!key) console.error(&#39;[localStorage Error]: Key is a must parameter&#39;);    try {   data = JSON.parse(localStorage.getItem(key)); } catch (error) {   return localStorage.getItem(key); }    if (!data) return null;    if (!Boolean(data.expires) || data.expires &gt;= nowTime) {   return data.data; } else {   localStorage.removeItem(key);   return null; }}   clearStorage(key)   清除localStorage```javascript/**   @method clearStorage   @param {string} key   /function clearStorage(key) { if (key) {   localStorage.removeItem(key); } else {   localStorage.clear(); }}```","categories":["javascript"]},{"title":"Cookies","url":"/2020/12/10/cookies.html","content":"setCookie(params)   设置Cookie```javascript/**   @method setCookie   @param {object} options   @param {string} options.key   @param {string} options.value   @param {number} [options.hours]   @param {string} [options.path]   - path: &#39;/&#39;   @param {string} [options.domain] - domain: document.domain   /function setCookie(options) { let time = new Date(), expires = &#39;&#39;, path = &#39;&#39;, domain = &#39;&#39;;    if (!options.key || !options.value) {   console.error(&#39;[Cookie Error]: key, value must be set.&#39;);   return; }    if (options.hours) {   try {   Number(options.hours);      } catch (e) {   console.error(&apos;[Cookie Error]: expires must is number.&apos;);      }      time.toGMTString(time.setTime(time.getTime() + 1000 * 60 * 60 * options.hours));   expires = &#39;expires=&#39; + time + &#39;;&#39;; }    if (options.path) path = &#39;path=&#39; + options.path + &#39;;&#39;;    if (options.domain) domain = &#39;domain=&#39; + options.domain;    document.cookie = options.key + &#39;=&#39; + options.value + &#39;;&#39; + expires + path + domain;}   getCookie(key)   获取Cookie```javascript/**   @method getCookie   @param {string} key    @return {undefined|string|null}   /function getCookie(key) { if (!key) {   console.error(&#39;[Cookie Error]: key is &#39; + (typeof key) + &#39;.&#39;);   return; } const regexp = new RegExp(&#39;(^|; )&#39; + key + &#39;=.*?(;|$)&#39;); const result = document.cookie.match(regexp); const value = result ? result[0].replace(/[; ]/g, &#39;&#39;).split(&#39;=&#39;)[1] : null; return value;}   deleteCookie(param)   ```javascript/**   @method deleteCookie   @param {string|object} param   @param {string} param.key   @param {string} [param.path]   @param {string} [param.domain]   @return {undefined|string|null}   /function deleteCookie(param) { const options = typeof param === &#39;object&#39; ? param : {}; const key = typeof param === &#39;string&#39; ? param : options.key;    if (!key) {   console.error(&#39;[Cookie Error]: key is &#39; + (typeof key) + &#39;.&#39;);   return; } if (options.path) path = &#39;path=&#39; + options.path + &#39;;&#39;; if (options.domain) domain = &#39;domain=&#39; + options.domain + &#39;;&#39;;    const regexp = new RegExp(&#39;(^|; )&#39; + key + &#39;=.*?(;|$)&#39;); const result = document.cookie.match(regexp); const item = result ? result[0].replace(/[; ]/g, &#39;&#39;) : &#39;&#39;; const time = new Date(); time.toGMTString(time.setTime(0)); document.cookie = item + &#39;;expires=&#39; + time + &#39;;&#39; + options.path + options.domain;}   clearCookie(params)   清除Cookie```javascript/**   @method clearCookie   @param {object} [options]   @param {string} [options.path]   @param {string} [options.domain]   /function clearCookie(options) { let arr = document.cookie.split(&#39;;&#39;), path = &#39;&#39;, domain = &#39;&#39;;    if (!options) options = {}; if (options.path) path = &#39;path=&#39; + options.path + &#39;;&#39;; if (options.domain) domain = &#39;domain=&#39; + options.domain + &#39;;&#39;;    for (let i = 0; i &lt; arr.length; i++) {   let key = arr[i].substring(0, arr[i].indexOf(&#39;=&#39;));   document.cookie = key + &#39;=0;expires=Thu, 01 Jan 1970 00:00:00 GMT;&#39; + path + domain; }}```","categories":["javascript"]},{"title":"Assist","url":"/2020/12/10/assist.html","content":"方法集合：   方法名称   描述   typeOf   验证数据类型。   deepCopy   深拷贝。   uuid   生成 UUID。   download   下载。   getUrlArg   根据名称获取路径参数。   getUrlQuery   将路径参数转化为对象格式。   setUrlQuery   将对象格式转化为路径参数。   getDeepValueOfObject   获取对象深层值。   toThousands   转化为千位分隔符格式。   typeOf(anything)   验证数据类型。   返回值均为字符串   /*** @method typeOf* @param {any} obj* @return {string}*/function typeOf(obj) {const toString = Object.prototype.toString;const map = {  '[object Boolean]': 'boolean',  '[object Number]': 'number',  '[object String]': 'string',  '[object Function]': 'function',  '[object Array]': 'array',  '[object Date]': 'date',  '[object RegExp]': 'regExp',  '[object Undefined]': 'undefined',  '[object Null]': 'null',  '[object Object]': 'object'};return map[toString.call(obj)];}   console.log(typeOf(&#39;abc&#39;)); // stringconsole.log(typeOf([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])); // arrayconsole.log(typeOf({ a: 1, b: 2, c: 3 })); // object   * #### deepCopy(data)深拷贝。&gt; 该方法需要结合 `typeOf()` 方法一起使用```javascript/** * @method deepCopy * @param {object|array} data * @return {object|array} */function deepCopy(data) {  const type = typeOf(data);  let object;  if (type === &apos;array&apos;) {    object = [];  } else if (type === &apos;object&apos;) {    object = {};  } else {    return data;  }  if (type === &apos;array&apos;) {    for (let i = 0; i &lt; data.length; i ++) {      object.push(deepCopy(data[i]));    }  } else if (type === &apos;object&apos;) {    for (const key in data) {      if (data.hasOwnProperty(key)) {        object[key] = deepCopy(data[key]);      }    }  }  return object;}const obj1 = { a: 1, b: 2, c: 3 };const obj2 = deepCopy(obj1);console.log(obj1 === obj2); // false   formatDate(date, format)   日期格式化。   function formatDate(time, format = 'yyyy-MM-dd hh:mm:ss') {const date = time ? new Date(time) : new Date();const dateObjects = {  'M+': date.getMonth() + 1, // 月  'd+': date.getDate(), // 日  'h+': date.getHours(), // 时  'm+': date.getMinutes(), // 分  's+': date.getSeconds(), // 秒  'q+': Math.floor((date.getMonth() + 3) / 3), // 季度  'S': date.getMilliseconds() // 毫秒};if (/(y{4})/.test(format)) {  format = format.replace(RegExp.$1, (date.getFullYear() + '').substr(4 - RegExp.$1.length));}for (const key in dateObjects) {  if (new RegExp('(' + key + ')').test(format)) {    format = format.replace(RegExp.$1, (RegExp.$1.length === 1) ? dateObjects[key] : ('00' + dateObjects[key]).substr(('' + dateObjects[key]).length));  }}return format;}   uuid()   生成 UUID。   /*** @method uuid* @return {string}*/function uuid() {return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {  const r = Math.random() * 16 | 0;  const v = c === 'x' ? r : (r &amp; 0x3 | 0x8);  return v.toString(16);});}   console.log(uuid()); // xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx   * #### download(url, name)下载。```javascript/** * @method download * @param {string} url * @param {string} name */function download(url, name) {  const aDom = document.createElement(&apos;a&apos;);  aDom.download = name;  aDom.href = url;  document.body.appendChild(aDom);  aDom.click();  aDom.remove();}console.log(download(&apos;word.docx&apos;, &apos;https://www.test.com/word.docx&apos;)); // word.docx   getUrlArg(name)   根据名称获取路径参数。   /*** @method getUrlArg* @param {string} name* @return {string}*/function getUrlArg(name) {const search = window.location.search;const regexp = new RegExp(`(^|&amp;)${name}=([^&amp;]*)(&amp;|$)`);const arg = search.substr(1).match(regexp);return arg ? arg[2] : '';}   getUrlQuery(url)   将路径参数转化为对象格式。   /*** @method getUrlQuery* @param {string} url* @return {object}*/function getUrlQuery(url) {const query = url.substring(url.indexOf('?') + 1).split('&amp;');const params = {};query.forEach(item =&gt; {  const key_value = item.split('=');  params[key_value[0]] = key_value[1];});return params;}   const url = &#39;   https://www.test.com/query?a=1&amp;b=2&amp;c=3&#39;   ;console.log(getUrlQuery(url)); // { a: 1, b: 2, c: 3 }   * #### setUrlQuery(url)将对象格式转化为路径参数。```javascript/** * @method setUrlQuery * @param {object} params * @return {string} */function setUrlQuery(params) {  const querys = [];  for (const key in params) {    if (params.hasOwnProperty(key)) {      querys.push(key + &apos;=&apos; + params[key]);    }  }  return querys.join(&apos;&amp;&apos;);}const params = { a: 1, b: 2, c: 3 };console.log(setUrlQuery(params)); // &apos;a=1&amp;b=2&amp;c=3&apos;   getDeepValueOfObject(object, keyPath, defaultValue)   获取对象深层值。   /*** @method getDeepValueOfObject* @param {object|array} object* @param {string} keyPath* @param {any} [defaultValue]* @return {any}*/function getDeepValueOfObject(object, keyPath, defaultValue) {const isString = typeof keyPath === 'string';if (!isString) {  console.warn('[getDeepValueOfObject warn]: keyPath is not a string, type ' + typeof keyPath);}if (object &amp;&amp; keyPath &amp;&amp; isString) {  const keys = keyPath.split('.');  let value = object;  for (let index = 0; index &lt; keys.length; index++) {    const key = keys[index];    if (value[key] !== undefined) {      value = value[key];    } else {      value = defaultValue;    }  }  return value;} else {  return defaultValue;}}   const obj = {  foo: {    number: 3  },  bar: 2,};const arr = [ obj ];   console.log(getDeepValueOfObject(obj, &#39;foo.number&#39;)); // 3console.log(getDeepValueOfObject(obj, &#39;bar.number&#39;)); // undefinedconsole.log(getDeepValueOfObject(obj, &#39;bar.number&#39;, &#39;default&#39;)); // &#39;default&#39;console.log(getDeepValueOfObject(obj, &#39;&#39;)); // undefinedconsole.log(getDeepValueOfObject(obj, &#39;&#39;, &#39;default&#39;)); // &#39;default&#39;console.log(getDeepValueOfObject(arr, 0)); // undefinedconsole.log(getDeepValueOfObject(arr, &#39;0.foo.number&#39;)); // 3   * #### toThousands(number)转化为千位分隔符格式```javascript/** * @method toThousands * @param {number|string} number * @return {string} */function toThousands(number) {  if (Math.abs(Number(number)) &gt;= 1000) {    const [integer, float] = (number || 0).toString().split(&apos;.&apos;);    const thousandsInteger = integer.replace(/(\\d)(?=(?:\\d{3})+$)/g, &apos;$1,&apos;);    return thousandsInteger + (float ? &apos;.&apos; + float : &apos;&apos;);  } else {    return number;  }}","categories":["javascript"]},{"title":"黄瓜炒香肠","url":"/2020/12/05/sauteed-cucumber-sausage.html","content":"食材用料   食材   数量   黄瓜   1根   香肠   2根   油   适量   蒜   适量   盐   适量   鸡精   适量   生抽   适量   做法步骤   图片   步骤   1.    准备食材   2.    蒜切末装盘   3.    黄瓜切成片   4.    香肠斜切成片   5.    热锅热油，下香肠，炒至表面略焦装盘备用   6.    另起油下蒜末爆香   7.    下黄瓜片翻炒均匀   8.    加入香肠、盐、生抽和鸡精翻炒均匀   9.    收锅   10.    装盘","categories":["cookbook"]},{"title":"芹菜炒肉","url":"/2020/11/30/celery-fried-meat.html","content":"食材用料   食材   数量   芹菜   200克   鸡胸肉   半块   油   适量   蒜   适量   胡椒粉   适量   淀粉   适量   盐   适量   生抽   适量   做法步骤   图片   步骤   1.    准备食材   2.    准备调料：蒜切片   3.    芹菜切段，焯水   4.    肉切片，捏掉水，加入生抽、胡椒粉、淀粉   5.    搅拌至粘稠   6.    放油中火，放入调料爆香   7.    放入肉片翻炒   8.    放入芹菜段，再加入一点点水大火翻炒   9.    放盐、一点点老抽翻炒   10.    收锅   11.    装盘","categories":["cookbook"]},{"title":"芹菜香肠炒鸡蛋","url":"/2020/11/29/scrambled-eggs-with-celery-sausage.html","content":"食材用料   食材   数量   芹菜   150克   香肠   2根   鸡蛋   2个   油   少量   蒜   适量   盐   适量   生抽   适量   做法步骤   图片   步骤   1.    准备食材   2.    蒜切末装起来   3.    芹菜切段   4.    香肠切片   5.    鸡蛋打散   6.    热锅热油，倒入鸡蛋炒成定型，盛出备用   7.    锅烧热，下油加香肠炒一下   8.    香肠表面略焦加入蒜末和芹菜翻炒   9.    加入鸡蛋、盐、生抽翻炒入味   10.    收锅   11.    装盘","categories":["cookbook"]},{"title":"手撕鸡肉","url":"/2020/11/27/hand-tore-the-chicken.html","content":"食材用料   食材   数量   无骨鸡腿   2个   姜   适量   料酒   适量   葱   适量   蒜   适量   辣椒粉   适量   盐   适量   生抽   适量   香油   适量   藤椒油   适量   做法步骤   图片   步骤   1.    准备食材   2.    煮鸡腿调料：葱段、姜片、盐和料酒   3.    锅中放鸡腿、煮鸡腿调料，加水开始煮20分钟左右   4.    期间准备腌料：葱段、蒜末、辣椒粉、盐、生抽、藤椒油、香油   5.    鸡腿煮好后捞出撕碎   6.    把腌料倒进去拌匀   7.    装盘","categories":["cookbook"]},{"title":"麻辣鸡中翅","url":"/2020/10/31/spicy-chicken-medium-wing.html","content":"食材用料   食材   数量   鸡中翅   4块   油   少量   葱   适量   姜   适量   蒜   适量   八角   2个   辣椒圈   适量   花椒   适量   盐   适量   生抽   适量   老抽   适量   香油   适量   鸡翅必须焯水去血沫，不然菜味会变腥。   做法步骤   图片   步骤   1.    准备食材   2.    葱切葱花，蒜切末，姜切片，和辣椒圈花椒八角装起来   3.    鸡中翅解冻洗净割口（想入味又不想割口可以拿牙签刺）   4.    热锅热油，下鸡中翅炒至表面金黄   5.    下葱花、蒜末、辣椒圈、花椒、八角爆香   6.    加入半碗水、生抽、老抽、盐   7.    汤汁剩少许时加入香油出锅   8.    装盘","categories":["cookbook"]},{"title":"青菜炒肉","url":"/2020/10/31/green-vegetables-meat.html","content":"食材用料   食材   数量   青菜   250克   鸡胸肉   半块   油   多量   蒜   适量   辣椒圈   适量   花椒   适量   盐   适量   生抽   适量   老抽   适量   青菜不出水关键：多放油，炒完菜最后放盐。   做法步骤   图片   步骤   1.    准备食材   2.    准备调料：蒜切片、花椒、辣椒圈   3.    青菜洗净焯水   4.    肉切片，捏掉水，加入淀粉、生抽、一点点老抽   5.    搅拌至粘稠   6.    放油中火，放入蒜、辣椒圈、花椒爆香   7.    放入肉片翻炒至肉熟   8.    翻入青菜大火翻炒   9.    最后放入盐简单翻炒两下入味   10.    出锅   11.    装盘","categories":["cookbook"]},{"title":"土豆块炖肉","url":"/2020/10/21/potato-cubes-stew-with-meat.html","content":"食材用料   食材   数量   土豆   400克   鸡胸肉   半块   油   适量   葱   适量   姜   适量   蒜   适量   辣椒圈   适量   花椒   适量   桂叶   1片   盐   适量   老抽   少量   生抽   适量   做法步骤   图片   步骤   1.    准备食材   2.    准备调料：葱花、蒜末、辣椒圈、花椒   3.    土豆切成块，加清水泡防止变色   4.    肉切片，捏掉水   5.    放油放入调料爆香   6.    中火放入肉炒熟   7.    放入土豆块翻炒均匀   8.    放入生抽、老抽、盐大火翻炒   9.    放香叶，加水，没过食材，大火收汁   10.    收锅   11.    装盘","categories":["cookbook"]},{"title":"土豆肉丝","url":"/2020/10/21/potato-with-meat-shreds.html","content":"食材用料   食材   数量   土豆   250克   猪肉   120克   油   适量   青椒   适量   蒜   适量   干辣椒   适量   花椒   适量   盐   适量   生抽   适量   做法步骤   图片   步骤   1.    准备食材   2.    青椒切条，蒜切片，和辣椒圈花椒装起来   3.    土豆切成丝，冲洗一遍去掉淀粉，加清水泡防止变色   4.    猪肉切成丝   5.    肉丝解冻，捏去多余水分   6.    热锅热油，油冒烟下肉丝爆香翻炒（肉丝有水注意锅里油乱蹦）   7.    放入青椒调料等，翻炒爆香   8.    放入土豆丝翻炒均匀，加入生抽、盐后翻炒均匀入味   9.    收锅   10.    装盘","categories":["cookbook"]},{"title":"React PropTypes","url":"/2020/09/17/react-proptypes.html","content":"Install   $ npm install prop-types --save   Use   Grammar One：   class Greeting extends Component {  static propTypes = {    className: PropTypes.string,    style: PropTypes.object,  };  static defaultProps = {    className: '',  };  render() { ... }}   Grammar Two：   class Greeting extends Component { ... }Greeting.propTypes = {  className: PropTypes.string,};Greeting.defaultProps = {  className: '',};   String   string: PropTypes.string   Number   number: PropTypes.number   Boolean   bool: PropTypes.bool   Array   array: PropTypes.array   Object   object: PropTypes.object   Symbol   symbol: PropTypes.symbol   Function   func: PropTypes.func   Required   // 必填isRequired: PropTypes.isRequiredstringIsRequired: PropTypes.string.isRequired   Anything   // 任意类型的数据any: PropTypes.any   Node   // 任何可被渲染的元素（包括数字、字符串、子元素或数组）node: PropTypes.node   Element   // 一个 React 元素element: PropTypes.element   ElementType   // 一个 React 元素类型（即，MyComponent）elementType: PropTypes.elementType   InstanceOf   // 声明属性为某个类的实例，这里使用 JS 的 instanceof 操作符实现。instanceOf: PropTypes.instanceOf(Message)   OneOf   // 限制你的属性值是某个特定值之一oneOf: PropTypes.oneOf(['News', 'Photos'])   OneOfType   // 限制它为列举类型之一的对象oneOfType: PropTypes.oneOfType([  PropTypes.string,  PropTypes.number,  PropTypes.instanceOf(Message)])   ArrayOf   // 一个指定元素类型的数组arrayOf: PropTypes.arrayOf(PropTypes.number)   ObjectOf   // 一个指定类型的对象objectOf: PropTypes.objectOf(PropTypes.number)   Shape   // 一个指定属性及其类型的对象objectWithShape: PropTypes.shape({  color: PropTypes.string,  fontSize: PropTypes.number})","categories":["react"]},{"title":"前端自动部署 GitHub Page","url":"/2019/12/05/deploy-github-page.html","content":"自己的项目部署在GitHub Page的时候很麻烦，要先build然后再把文件推到master/docs或者gh-pages分支上面，现在github有一个插件可以帮你完成上面步骤：   github地址：   gh-pages   安装：   $ npm install gh-pages --save-dev   注意：该模块需要git版本大于等于1.9   配置：   在 package.json 的 script 字段中添加以下代码   \"scripts\": {  \"deploy\": \"npm run build &amp; gh-pages -d dist\",}   接下来运行    npm run deploy    就会先执行build命令，然后开始向该项目的gh-pages分支推送刚build的文件，随后在github项目的 Settings &gt; GitHub Pages 在 Sourse 中选择 gh-pages branch ，稍等几分钟后打开网址查看   https://${username}.github.io/${project}   命令行参数说明   参数   说明   -d   要推送文件的目录，这里写的是项目根目录 dist 文件夹。   -m   推送信息，信息如果过长带空格的话在json中需要加上双引号    -m \\&quot;Update GitHub Page\\&quot;   -b   推送的分支，默认gh-pages   更多参数请在命令行中输入以下命令   $ gh-pages --help","categories":["note"]},{"title":"安装MySQL","url":"/2019/11/13/mysql-install.html","content":"Windows 上安装 MySQL   Windows 上安装 MySQL 相对来说会较为简单，最新版本可以在    MySQL 下载    中下载中查看(更详细安装：   Windows 上安装 MySQL   )。   点击 Download 按钮进入下载页面，点击下图中的 No thanks, just start my download. 就可立即下载：   下载完后，解压完成后为以下样子（我将安装文件放在 D:\\mysql 中）：   接下来我们需要配置下 MySQL 的配置文件   打开刚刚解压的文件夹 D:\\mysql ，在该文件夹下创建 my.ini 配置文件，编辑 my.ini 配置以下基本信息：   [client]# 设置mysql客户端默认字符集default-character-set=utf8[mysqld]# 设置3306端口port = 3306# 设置mysql的安装目录basedir=C:\\\\web\\\\mysql-8.0.11# 设置 mysql数据库的数据的存放目录，MySQL 8+ 不需要以下配置，系统自己生成即可，否则有可能报错# datadir=C:\\\\web\\\\sqldata# 允许最大连接数max_connections=20# 服务端使用的字符集默认为8比特编码的latin1字符集character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB   接下来我们来启动下 MySQL 数据库：   以管理员身份打开 cmd 命令行工具，切换目录：   $ cd C:\\web\\mysql-8.0.11\\bin   初始化数据库：   $ mysqld --initialize --console   注意：这个可能会报错：   mysqld : 无法将“mysqld”项识别为 cmdlet、函数、脚本文件或可运行程序的名称。请检查名称的拼写，如果包括路径，请确保路径正确，然后再试一次。   解决办法有两个：1、在命令前面加上 ./ 如：   $ ./mysqld --initialize --console   2、   配置 mysql 环境变量   执行完成后，会输出 root 用户的初始默认密码，如：   ...2019-11-13T09:36:49.186128Z 5 [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: &lt;!wbLjV?/3uq   &lt;!wbLjV?/3uq 就是初始密码，后续登录需要用到，你也可以在登陆后修改密码。输入以下安装命令：   $ mysqld install   启动输入以下命令即可：   $ net start mysql   登录 MySQL   当 MySQL 服务已经运行时, 我们可以通过 MySQL 自带的客户端工具登录到 MySQL 数据库中, 首先打开命令提示符, 输入以下格式的命名:   $ mysql -h 主机名 -u 用户名 -p   参数说明：   -h : 指定客户端所要登录的 MySQL 主机名, 登录本机(localhost 或 127.0.0.1)该参数可以省略;   -u : 登录的用户名;   -p : 告诉服务器将会使用一个密码来登录, 如果所要登录的用户名密码为空, 可以忽略此选项。   如果我们要登录本机的 MySQL 数据库，只需要输入以下命令即可：   $ mysql -u root -p   按回车确认, 如果安装正确且 MySQL 正在运行, 会得到以下响应:   $ Enter password:   若密码存在, 输入密码登录, 不存在则直接按回车登录。登录成功后你将会看到 Welcome to the MySQL monitor... 的提示语。然后命令提示符会一直以 mysq&gt; 加一个闪烁的光标等待命令的输入, 输入 exit 或 quit 退出登录。   配置 mysql 环境变量   上面安装的是时候我们看到mysql默认安装路径是：D:\\mysql 我的电脑右键—&gt;属性—&gt;高级系统设置—&gt;环境变量—&gt;新建MYSQL_HOME,将安装目录输入：   找到path编辑：输入%MYSQL_HOME%\\bin   打开 cmd 输入    mysql    检测一下   在 navicat for mysql 上链接 mysql   navicat for mysql 下载    安装完成后运行 navicat    客户端使用 navicat for mysql。本地安装了mysql 8.0。但是在链接的时候提示：   解决方法：   这行代码有两层含义，第一:修改root的密码为&#39;root&#39;，摒弃原来的旧密码。第二：使用mysql_native_password对新密码进行编码。   $ ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'root';   详情报错信息请看    navicat for mysql 链接时报错：1251...","categories":["database"]},{"title":"海浪涛天，一个老水兵的亲身经历","url":"/2019/10/31/wave-and-sky.html","content":"","categories":["reprint"]},{"title":"图片 JPEG 显示优化","url":"/2019/10/31/gradual-jpeg.html","content":"1. JPEG介绍   JPEG 是Joint Photographic Experts Group（联合图像专家小组）的缩写，是第一个国际图像压缩标准。JPEG图像压缩算法能够在提供良好的压缩性能的同时，具有比较好的重建质量，被广泛应用于图像、视频处理领域。   2. 保存方式   JPEG文件格式有两种保存方式。他们是Baseline JPEG和Progressive JPEG.两种格式有相同尺寸以及图像数据，他们的扩展名也是相同的，唯一的区别是二者显示的方式不同。   2.1 Baseline JPEG （基线）   这种类型的JPEG文件存储方式是按从上到下的扫描方式，把每一行顺序的保存在JPEG文件中。打开这个文件显示它的内容时，数据将按照存储时的顺序从上到下一行一行的被显示出来，直到所有的数据都被读完，就完成了整张图片的显示。如果文件较大或者网络下载速度较慢，那么就会看到图片被一行行加载的效果，这种格式的JPEG没有什么优点，因此，一般都推荐使用Progressive JPEG   2.2 Progressive JPEG （渐进）   和Baseline一遍扫描不同，Progressive JPEG文件包含多次扫描，这些扫描顺寻的存储在JPEG文件中。打开文件过程中，会先显示整个图片的模糊轮廓，随着扫描次数的增加，图片变得越来越清晰。这种格式的主要优点是在网络较慢的情况下，可以看到图片的轮廓知道正在加载的图片大概是什么。在一些网站打开较大图片时，你就会注意到这种技术。   3. 如何创建   使用Photoshop   文件 &gt; 存储为 &gt; 先点击保存，随后会弹出JPEG选项   如果想创建渐进式JPEG，选择连续   4. 应用   基本JPEG和渐进JPEG该什么时候使用？   当您的JPEG图像低于10K时，最好保存为基本JPEG（估计有75％的可能性会更小）对于超过10K的文件，渐进式JPEG将为您提供更好的压缩（在94％的情况下）Chrome + Firefox + IE9浏览器下，渐进式图片加载更快，而且是快很多，至于其他浏览器，与基本式图片的加载一致，至少不会拖后腿。   渐进式图片也有不足，就是吃CPU吃内存。","categories":["note"]},{"title":"母鸡与前端工程师","url":"/2019/10/25/hen-and-front-end-engineer.html","content":"","categories":["reprint"]},{"title":"Object","url":"/2019/10/24/object.html","content":"JavaScript Object 对象   语法   var obj = new Object();// 等价于下面：var obj = {};   对象属性   可以说 &#39;JavaScript 对象是变量的容器&#39;。但是，我们通常认为 &#39;JavaScript 对象是键值对的容器&#39;。键值对通常写法为 name : value (键与值以冒号分割)。键值对在 JavaScript 对象通常称为 对象属性。   对象键值对的写法类似于：   PHP 中的关联数组   Python 中的字典   C 语言中的哈希表   Java 中的哈希映射   Ruby 和 Perl 中的哈希表   ES6 方法：   方法名称   描述   Object.assign   该方法主要用于对象的合并。   Object.keys   返回一个由一个给定对象的自身可枚举属性组成的数组。   Object.values   返回一个给定对象自己的所有可枚举属性值的数组。   Object.entries   返回一个给定对象自身可枚举属性的键值对数组。   Object.freeze   冻结一个对象。   Object.preventExtensions   对象不能再添加新的属性。   Object.isExtensible   判断对象是否是可扩展的。   Object.seal   让一个对象密封，并返回被密封后的对象。   Object.isSealed   判断一个对象是否被密封。   hasOwnProperty   判断对象自身属性中是否具有指定的属性。   Object.create   使用指定的原型对象及其属性去创建一个新的对象。   Object.defineProperties   直接在一个对象上定义新的属性或修改现有属性，并返回该对象。   Object.defineProperty   在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回这个对象。   Object.getOwnPropertyDescriptor   返回指定对象上一个自有属性对应的属性描述符。   Object.getOwnPropertyDescriptors   获取一个对象的所有自身属性的描述符。   Object.getOwnPropertyNames   返回一个由指定对象的所有自身属性的属性名组成的数组。   Object.getOwnPropertySymbols   返回一个给定对象自身的所有 Symbol 属性的数组。   Object.getPrototypeOf   返回指定对象的原型（内部[[Prototype]]属性的值，即proto，而非对象的prototype）。   isPrototypeOf   判断一个对象是否存在于另一个对象的原型链上。   Object.setPrototypeOf   设置对象的原型对象。   Object.is   判断两个值是否相同。   Object.assign(target, source1, source2, ...)   该方法主要用于对象的合并，将源对象source的所有可枚举属性合并到目标对象target上,此方法只拷贝源对象的自身属性，不拷贝继承的属性。   Object.assign    方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。同名属性会替换。   Object.assign    只能进行值的复制，如果要复制的值是一个取值函数，那么将求值后再复制。   Object.assign    可以用来处理数组，但是会把数组视为对象。   const target = { x: 0, y: 1 };const source = {x: 1,z: 2,fn: {  number: 1}};   Object.assign(target, source);// target  {x : 1, y : 1, z : 2, fn : {number : 1}}    // 同名属性会被覆盖// source  {x : 1, z : 2, fn : {number : 1}}target.fn.number = 2;                                  // 拷贝为对象引用// source  {x : 1, z : 2, fn : {number : 2}}   function Person() {  this.name = 1}Person.prototype.country = &#39;china&#39;;   let student = new Person();student.age = 29;const young = {insterst: &#39;sport&#39;};   Object.assign(young, student);// young {instest : &#39;sport&#39; , age : 29, name: 1} // 只能拷贝自身的属性，不能拷贝prototype   Object.assign([1, 2, 3], [4, 5]); // 把数组当作对象来处理// [4, 5, 3]   * #### Object.keys(obj)返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用 `for...in` 循环遍历该对象时返回的顺序一致 （两者的主要区别是 一个 for-in 循环还会枚举其原型链上的属性）。```javascript/* Array 对象 */const arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];console.log(Object.keys(arr)); // [&apos;0&apos;, &apos;1&apos;, &apos;2&apos;]/* Object 对象 */const obj = { foo: &apos;bar&apos;, baz: 42 };console.log(Object.keys(obj)); // [&apos;foo&apos;,&apos;baz&apos;]    Object.values(obj)   返回一个给定对象自己的所有可枚举属性值的数组，值的顺序与使用    for...in    循环的顺序相同 ( 区别在于 for-in 循环枚举原型链中的属性 )。   Object.values    会过滤属性名为 Symbol 值的属性。   const an_obj = { 100: 'a', 2: 'b', 7: 'c' };console.log(Object.values(an_obj)); // ['b', 'c', 'a']   const obj = { 0: &#39;a&#39;, 1: &#39;b&#39;, 2: &#39;c&#39; };console.log(Object.values(obj)); // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]   * #### Object.entries(obj)返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 `for...in` 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环也枚举原型链中的属性）。```javascriptconst obj = { foo: &apos;bar&apos;, baz: 42 };console.log(Object.entries(obj)); // [ [&apos;foo&apos;, &apos;bar&apos;], [&apos;baz&apos;, 42] ]const simuArray = { 0: &apos;a&apos;, 1: &apos;b&apos;, 2: &apos;c&apos; };console.log(Object.entries(simuArray)); // [ [&apos;0&apos;, &apos;a&apos;], [&apos;1&apos;, &apos;b&apos;], [&apos;2&apos;, &apos;c&apos;] ]   Object.freeze(obj)   冻结一个对象，冻结指的是不能向这个对象添加新的属性，不能修改其已有属性的值，不能删除已有属性，以及不能修改该对象已有属性的可枚举性、可配置性、可写性。也就是说，这个对象永远是不可变的。该方法返回被冻结的对象。const obj = {prop: function() {},foo: 'bar'};   // 新的属性会被添加, 已存在的属性可能// 会被修改或移除obj.foo = &#39;baz&#39;;obj.lumpy = &#39;woof&#39;;delete obj.prop;   // 作为参数传递的对象与返回的对象都被冻结// 所以不必保存返回的对象（因为两个对象全等）const obj2 = Object.freeze(obj);   obj2 === obj; // trueObject.isFrozen(obj); // === true   // 现在任何改变都会失效obj.foo = &#39;quux&#39;; // 静默地不做任何事// 静默地不添加此属性obj.quaxxor = &#39;the friendly duck&#39;;console.log(obj)   * #### Object.isFrozen(obj)判断一个对象是否被冻结 .* #### Object.preventExtensions(obj)对象不能再添加新的属性。可修改，删除现有属性，不能添加新属性。```javascriptconst obj = {  name:&apos;lilei&apos;,  age: 30 ,  sex: &apos;male&apos;}obj = Object.preventExtensions(obj);console.log(obj);    // {name: &apos;lilei&apos;, age: 30, sex: &apos;male&apos;}obj.name = &apos;haha&apos;;console.log(obj)     // {name: &apos;haha&apos;, age: 30, sex: &apos;male&apos;}delete obj.sex ;console.log(obj);    // {name: &apos;haha&apos;, age: 30}obj.address  = &apos;china&apos;;console.log(obj)     // {name: &apos;haha&apos;, age: 30}   Object.isExtensible(obj)   判断对象是否是可扩展的，Object.preventExtensions，Object.seal 或 Object.freeze 方法都可以标记一个对象为不可扩展（non-extensible）   Object.seal(obj)   Object.seal()    方法可以让一个对象密封，并返回被密封后的对象。密封一个对象会让这个对象变的不能添加新属性，且所有已有属性会变的不可配置。属性不可配置的效果就是属性变的不可删除，以及一个数据属性不能被重新定义成为访问器属性，或者反之。但属性的值仍然可以修改。尝试删除一个密封对象的属性或者将某个密封对象的属性从数据属性转换成访问器属性，结果会静默失败或抛出   TypeError 异常. 不会影响从原型链上继承的属性。但    proto    (  ) 属性的值也会不能修改。   const obj = {prop: function () {},foo: 'bar'};   // 可以添加新的属性,已有属性的值可以修改,可以删除obj.foo = &#39;baz&#39;;obj.lumpy = &#39;woof&#39;;delete obj.prop;   const obj2 = Object.seal(obj);   assert(obj2 === obj);assert(Object.isSealed(obj) === true);   // 仍然可以修改密封对象上的属性的值.obj.foo = &#39;quux&#39;;   // 但你不能把一个数据属性重定义成访问器属性.Object.defineProperty(  obj,   &#39;foo&#39;,   {     get: function() {       return &#39;g&#39;;     }  }); // 抛出TypeError异常   // 现在,任何属性值以外的修改操作都会失败.obj.quaxxor = &#39;the friendly duck&#39;; // 静默失败,新属性没有成功添加delete obj.foo; // 静默失败,属性没有删除成功   // ...在严格模式中,会抛出TypeError异常function fail() {  &#39;use strict&#39;;  delete obj.foo; // 抛出TypeError异常  obj.sparky = &#39;arf&#39;; // 抛出TypeError异常}   fail();   // 使用Object.defineProperty方法同样会抛出异常Object.defineProperty(obj, &#39;ohai&#39;, { value: 17 }); // 抛出TypeError异常Object.defineProperty(obj, &#39;foo&#39;, { value: &#39;eit&#39; }); // 成功将原有值改变   * #### Object.isSealed(obj)判断一个对象是否被密封* #### hasOwnProperty()判断对象自身属性中是否具有指定的属性。```javascriptobj.hasOwnProperty(&apos;name&apos;) // true or false   Object.create(prototype[,propertiesObject])   使用指定的原型对象及其属性去创建一个新的对象。   const parent = {x: 1,y: 1};const child = Object.create(parent,{z: {                           // z会成为创建对象的属性  writable: true,  configurable: true,  value: 'newAdd'}});console.log(child)   Object.defineProperties(obj, props)   直接在一个对象上定义新的属性或修改现有属性，并返回该对象。   const obj = {};Object.defineProperties(obj, {'property1': {  value: true,  writable: true},'property2': {  value: 'Hello',  writable: false}// etc. etc.});console.log(obj);   // {property1: true, property2: 'Hello'}   Object.defineProperty(obj, prop, descriptor)   在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。   Object.defineProperty(Object, 'is', {value: function(x, y) {  if (x === y) {    // 针对+0 不等于 -0的情况    return x !== 0 || 1 / x === 1 / y;  }  // 针对NaN的情况  return x !== x &amp;&amp; y !== y;},configurable: true,enumerable: false,writable: true });    // 注意不能同时设置(writable，value) 和 get，set方法，否则// 浏览器会报错： Invalid property descriptor. Cannot both specify accessors and a value or writable attribute   * #### Object.getOwnPropertyDescriptor(obj, prop)返回指定对象上一个自有属性对应的属性描述符。（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性）.如果指定的属性存在于对象上，则返回其属性描述符对象（property descriptor），否则返回 undefined。```javascriptconst arr = [&apos;name&apos;,&apos;age&apos;] ;arr.forEach(val =&gt; console.log(Object.getOwnPropertyDescriptor(obj,val)));// { value: &apos;js&apos;, writable: true, enumerable: true, configurable: true }// undefined   Object.getOwnPropertyDescriptors(obj)   获取一个对象的所有自身属性的描述符。   const obj = {name: 'js',age: 20};console.log(Object.getOwnPropertyDescriptors(obj));// {//   name: {//     configurable: true,//     enumerable: true,//     value: 'js',//     writable: true,//   },//   age: {//     configurable: true,//     enumerable: true,//     value: 20,//     writable: true,//   }// }   Object.getOwnPropertyNames()   返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括Symbol值作为名称的属性）组成的数组。   const obj = { 0: 'a', 1: 'b', 2: 'c'};   Object.getOwnPropertyNames(obj).forEach(function(val) {  console.log(val);});   const obj = {  x: 1,  y: 2};   Object.defineProperty(obj,&#39;z&#39;,{    enumerable : false});console.log(Object.getOwnPropertyNames(obj));  // [&#39;x&#39;, &#39;y&#39;, &#39;z&#39;] 包含不可枚举属性 。console.log(Object.keys(obj));                 // [&#39;x&#39;, &#39;y&#39;]      只包含可枚举属性 。   * #### Object.getOwnPropertySymbols()返回一个给定对象自身的所有 Symbol 属性的数组。* #### Object.getPrototypeOf()返回指定对象的原型（内部[[Prototype]]属性的值，即__proto__，而非对象的prototype）。* #### isPrototypeOf()判断一个对象是否存在于另一个对象的原型链上。* #### Object.setPrototypeOf(obj, prototype)设置对象的原型对象* #### Object.is()判断两个值是否相同。&gt; 如果下列任何一项成立，则两个值相同：&gt; * 两个值都是 `undefined`&gt; * 两个值都是 `null`&gt; * 两个值都是 `true` 或者都是 `false`&gt; * 两个值是由相同个数的字符按照相同的顺序组成的字符串&gt; * 两个值指向同一个对象&gt; * 两个值都是数字并且:&gt;   1. 都是正零 `+0`&gt;   2. 都是负零 `-0`&gt;   3. 都是 `NaN`&gt;   4. 都是除零和 `NaN` 外的其它同一个数字```javascriptObject.is(&apos;foo&apos;, &apos;foo&apos;);     // trueObject.is(window, window);   // trueObject.is(&apos;foo&apos;, &apos;bar&apos;);     // falseObject.is([], []);           // falsevar test = { a: 1 };Object.is(test, test);       // trueObject.is(null, null);       // true// 特例Object.is(0, -0);            // falseObject.is(-0, -0);           // trueObject.is(NaN, 0/0);         // true","categories":["javascript"]},{"title":"RegExp","url":"/2019/10/22/regexp.html","content":"JavaScript RegExp 对象   语法   var regexp = new RegExp(pattern, modifiers);    // 通过 RegExp 构造函数创建var regexp = /[pattern]/[modifiers];            // 通过字面量创建   pattern（模式） 描述了表达式的模式   modifiers (修饰符) 用于指定全局匹配、区分大小写的匹配和多行匹配   注意：当使用构造函数创造正则对象时，需要常规的字符转义规则（在前面加反斜杠 \\）。比如，以下是等价的：    var regexp = new RegExp('\\\\w+');var regexp = /\\w+/;   修饰符   修饰符 (Modifiers) 用于指定全局匹配、区分大小写的匹配和多行匹配：   修饰符   描述   i   执行对大小写不敏感的匹配。   g   执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。   m   执行多行匹配。   s   允许 . 匹配换行符。   u   使用 unicode 码的模式进行匹配。   y   执行“粘性 (sticky)”搜索，匹配从目标字符串的当前位置开始。   量词   量词（Quantifiers）定义了重复匹配字符的确数或约数：   量词   描述   n+   匹配任何包含至少一个 n 的字符串。   n*   匹配任何包含零个或多个 n 的字符串。   n?   匹配任何包含零个或一个 n 的字符串。   n{X}   匹配包含 X 个 n 的序列的字符串。   n{X,}   匹配包含最少 x 个、最多 y 个 n 的序列的字符串。   n{X,Y}   匹配包含至少 x 个 n 的序列的字符串。   ^n   匹配任何开头为 n 的字符串。   n$   匹配任何结尾为 n 的字符串。   ?=n   匹配任何其后紧接指定字符串 n 的字符串。   ?!n   匹配任何其后没有紧接指定字符串 n 的字符串。   元字符   元字符（Metacharacter）是拥有特殊含义的字符：   元字符   描述   .   （小数点）默认匹配除   换行符   之外的任何单个字符。   \\w   匹配单词字符。   \\W   匹配非单词字符。   \\d   匹配数字。   \\D   匹配非数字字符。   \\s   匹配空白字符。   \\S   匹配非空白字符。   \\b   匹配单词边界。   \\B   匹配非单词边界。   \\0   匹配 NULL 字符。   \\n   匹配换行符。   \\f   匹配换页符。   \\r   匹配回车符。   \\t   匹配制表符。   \\v   匹配垂直制表符。   \\xxx   匹配以八进制数 xxx 规定的字符。   \\xdd   匹配以十六进制数 dd 规定的字符。   \\uxxxx   匹配以十六进制数 xxxx 规定的 Unicode 字符。   方括号   方括号用于查找某个范围内的字符：   表达式   描述   [^]   匹配任意任何字符。   [abc]   匹配方括号之间的任何字符。   [^abc]   匹配任何不在方括号之间的字符。   [0-9]   匹配任何从 0 至 9 的数字。   [a-z]   匹配任何从小写 a 到小写 z 的字符。   [A-Z]   匹配任何从大写 A 到大写 Z 的字符。   [A-z]   匹配任何从大写 A 到小写 z 的字符。   (red|blue|green)   匹配任何指定的选项。   RegExp 对象方法   表达式   描述   compile   编译正则表达式。   exec   检索字符串中指定的值。返回找到的值，并确定其位置。   test   检索字符串中指定的值。返回 true 或 false。   支持正则表达式的 String 对象的方法   表达式   描述   search   检索与正则表达式相匹配的值。。   match   找到一个或多个正则表达式的匹配。   replace   替换与正则表达式匹配的子串。   split   把字符串分割为字符串数组。   在多行文本中使用正则表达式   var string = 'Please yes\\nmake my day!';string.match(/yes.*day/); // nullstring.match(/yes[^]*day/); // 'yes\\nmake my day'   先行断言和先行否定断言   先行断言（lookahead）指的是，x只有在y前面才匹配，必须写成/x(?=y)/。比如，只匹配百分号之前的数字，要写成/\\d+(?=%)/。   var string = '100% of US presidents have been male';/\\d+(?=%)/.exec(string); // ['100']/have(?=%)/.exec(string); // null   先行否定断言（negative lookahead）x只有不在y前面才匹配，必须写成/x(?!y)/。比如，只匹配不在百分号之前的数字，要写成/\\d+(?!%)/。   var string = 'that’s all 44 of them';/\\d+(?!%)/.exec(string); // ['44']/\\d+(?!.*of)/.exec(string); // null/\\d+(?!.*all)/.exec(string); // ['44']/\\d+(?!.*of|.*all)/.exec(string); // null   后行断言和后行否定断言   ES2018 引入后行断言，V8 引擎 4.9 版（Chrome 62）已经支持。后行断言（lookbehind）指的是，x只有在y后面才匹配，必须写成/(?&lt;=y)x/。比如，只匹配美元符号之后的数字，要写成 /(?&lt;=\\$)\\d+/。   var string = 'Benjamin Franklin is on the $100 bill';/(?&lt;=\\$)\\d+/.exec(string);  // [\"100\"]   后行否定断言（negative lookbehind）指的是，x只有不在y后面才匹配，必须写成/(?&lt;!y)x/。比如，只匹配不在美元符号后面的数字，要写成 /(?&lt;!\\$)\\d+/。   var string = 'it’s is worth about €90';/(?&lt;!\\$)\\d+/.exec(string);  // [\"90\"]   贪婪模式和非贪婪模式   贪婪模式: 正则表达式一般趋向于最大长度匹配，总是尝试匹配尽可能多的字符。   var html = '&lt;html&gt;&lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;';var regexp = /(&lt;.*&gt;)/;html.match(regexp); // ['&lt;html&gt;&lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;']   非贪婪模式: 非贪婪匹配就是匹配到结果就好，总是尝试匹配尽可能少的字符。   var html = '&lt;html&gt;&lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;';var regexp = /(&lt;.*?&gt;)/;html.match(regexp); // ['&lt;html&gt;']   针对 6 种重复类惰性匹配的简单描述如下：   {n,m}?：尽量匹配 n 次，但是为了满足限定条件也可能最多重复 m 次。   {n}?：尽量匹配 n 次。   {n,}?：尽量匹配 n 次，但是为了满足限定条件也可能匹配任意次。   ??：尽量匹配，但是为了满足限定条件也可能最多匹配 1 次，相当于 {0,1}?。   +?：尽量匹配 1 次，但是为了满足限定条件也可能匹配任意次，相当于 {1,}?。   *? ：尽量不匹配，但是为了满足限定条件也可能匹配任意次，相当于 {0,}?。   捕获型分组和非捕获型分组   捕获型()：捕获型分组会把每个捕获分组所匹配的内容暂且存储在某个地方，以便下次使用。在JavaScript中，捕获性分组所匹配的内容都是以$1,$2,$3…的格式保存的。因此捕获型分组会有性能上的损失。   var string = 'sjds24324abcabc1234';var regexp = /(abc){2}/;string.match(regexp); // ['abcabc', 'abc']   非捕获型(?:)：非捕获型分组只会返回一个不含各个分组匹配（不含字串）的结果。所以会提高匹配速度。   var string = 'sjds24324abcabc1234';var regexp = /(?:abc){2}/;string.match(regexp); // ['abcabc']","categories":["javascript"]},{"title":"String","url":"/2019/10/21/string.html","content":"JavaScript String 对象   语法   var txt = new String('string');// 或者更简单方式：var txt = 'string';   方法集合：   方法名称   描述   replace   该方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。   slice   提取字符串的某个部分并在新字符串中返回被提取的部分。   substring   提取字符串中介于两个指定下标之间的字符。   substr   在字符串中抽取从 start 下标开始的指定数目的字符。   localeCompare   该方法返回一个数字来指示一个参考字符串是否在排序顺序前面或之后或与给定字符串相同。   replace(regexp/substr, replacement)   该方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。   参数   描述   regexp/substr   必需。规定子字符串或要替换的模式的 RegExp 对象。   请注意，如果该值是一个字符串，则将它作为要检索的直接量文本模式，而不是首先被转换为 RegExp 对象。   replacement/function   必需。一个字符串值或者一个函数。规定了替换文本或生成替换文本的函数。   请注意，如果该值是一个函数，每个匹配都调用该函数，它返回的字符串将作为替换文本使用。该函数的第一个参数是匹配模式的字符串。接下来的参数是与模式中的子表达式匹配的字符串，可以有 0 个或多个这样的参数。接下来的参数是一个整数，声明了匹配在 string 中出现的位置。最后一个参数是 string 本身。   1. Example   在本例中，我们将把 &quot;Doe, John&quot; 转换为 &quot;John Doe&quot; 的形式：   var name = 'Doe, John';name.replace(/(\\w+)\\s*, \\s*(\\w+)/, '$2 $1');   字符   替换文本   $1、$2、...、$99   与 regexp 中的第 1 到第 99 个子表达式相匹配的文本。   $&amp;   与 regexp 相匹配的子串。   $`   位于匹配子串左侧的文本。   $&#39;   位于匹配子串右侧的文本。   $$   直接量符号。   2. Example   在本例中，我们将把字符串中所有单词的首字母都转换为大写：   var words = 'hello word';words = words.replace(/\\b\\w+\\b/g, function(word) {return word.substring(0, 1).toUpperCase() + word.substring(1);});console.log(words); // Hello Word   \\b    匹配单词边界，    \\w    查找单词字符。   slice(start, end)   提取字符串的某个部分并在新字符串中返回被提取的部分。   该方法设置两个参数（可以为负数）：起始索引（开始位置），终止索引（结束位置）。   var str = \"Apple, Banana, Mango\";var res = str.slice(7, 13);// 等同var res = str.slice(-13, -7);console.log(res); // Banana   substring(start[, end])   提取字符串中介于两个指定下标之间的字符。   substring() 无法接受负的索引。如果省略第二个参数，则该 substring() 将裁剪字符串的剩余部分。   var str = \"Apple, Banana, Mango\";var res = str.substring(7);console.log(res); // Banana, Mango   substr(start[, length])   在字符串中抽取从 start 下标开始的指定数目的字符。   第二个参数规定被提取部分的长度。如果省略第二个参数，则该 substr() 将裁剪字符串的剩余部分。   var str = \"Apple, Banana, Mango\";var res = str.substr(7, 6);console.log(res); // Banana   localeCompare(compareString[, locales[, options]])   该方法返回一个数字来指示一个参考字符串是否在排序顺序前面或之后或与给定字符串相同。   参数   描述   compareString   用来比较的字符串。   locales   可选。 用来表示一种或多种语言或区域的一个符合 BCP 47 标准的字符串或一个字符串数组。   options   可选。详情   点击此处   根据汉字拼音首字母排序。   var names = [ '张三', '李四', '王五', '赵六' ];names.sort((a, b) =&gt; a.localeCompare(b, 'zh')); // ['李四', '王五', '张三', '赵六']","categories":["javascript"]},{"title":"Array","url":"/2019/10/10/array.html","content":"JavaScript Array 对象   语法   var cars = new Array('Saab', 'Volvo', 'BMW');// 等价于下面：var cars = ['Saab', 'Volvo', 'BMW'];   方法集合：   方法名称   描述   reduce   该方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。   splice   从数组中添加/删除项目，然后返回被删除的项目。   slice   从某个已有的数组返回选定的元素。   reduce(function(total, currentValue, currentIndex, arr), initialValue)   该方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。   参数   描述   total   必需。初始值, 或者计算结束后的返回值。   currentValue   必需。当前元素。   currentIndex   可选。当前元素的索引。   arr   可选。当前元素所属的数组对象。   initialValue   可选。传递给函数的初始值。   注意: reduce() 对于空数组是不会执行回调函数的。整合    map    和    filter    功能的例子   var arr = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ];var newArr = arr.reduce(function(total, currentValue, index, arr) {if (currentValue &lt;= 5) {  total.push(currentValue * 10);}return total;}, []);console.log(newArr); //  [0, 10, 20, 30, 40, 50]   splice(index, howmany, item1, ....., itemX)   从数组中添加/删除项目，然后返回被删除的项目。   参数   描述   index   必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。   howmany   必需。要删除的项目数量。如果设置为 0，则不会删除项目。   item1, ..., itemX   可选。向数组添加的新项目。   该方法会改变原始数组。   var fruits = ['Banana', 'Orange', 'Lemon', 'Apple', 'Mango'];var citrus = fruits.splice(1, 1, 'Watermelon');console.log(fruits); // ['Banana', 'Watermelon', 'Lemon', 'Apple', 'Mango'];console.log(citrus); // ['Watermelon'];   slice(start, end)   从某个已有的数组返回选定的元素。   参数   描述   start   必需。开始元素的索引。   end   可选。结束元素的索引。   slice()方法创建新数组。它不会从源数组中删除任何元素。如果结束参数被省略，slice() 会切出数组的剩余部分。   var fruits = ['Banana', 'Orange', 'Lemon', 'Apple', 'Mango'];var citrus = fruits.slice(1, 3); // ['Orange', 'Lemon'];var others = fruits.slice(3); // ['Apple', 'Mango'];","categories":["javascript"]},{"title":"VSCode","url":"/2019/09/21/vscode.html","content":"汉化教程：   https://jingyan.baidu.com/article/7e44095377c9d12fc1e2ef5b.html   插件   GitLens：显示某一行代码是谁写的   vscode-fileheader：显示文件作者修改信息   格式化代码快捷键：   Windows   Shift + Alt + F   Mac   Shift + Option + F   Ubuntu   Ctrl + Shift + I   开启 ESLint 验证：   {  \"editor.detectIndentation\": false,  \"editor.tabSize\": 2,  \"editor.insertSpaces\": true,  \"eslint.autoFixOnSave\": true,   // 保存文件时自动修复ESLint验证  \"eslint.validate\": [    {      \"language\": \"vue\",   //   该项是验证Vue文件并启动保存文件时自动修复ESLint验证      \"autoFix\": true    },    {      \"language\": \"javascriptreact\",   // React验证，同上      \"autoFix\": true    },    \"javascript\",    \"html\",  ],}   快捷键配置：   Emmet（展开缩写）:   要使该快捷键生效需在配置中设置   {  \"emmet.triggerExpansionOnTab\": true,  // 设置emmet展开标签时必要条件}   Redo（反撤销）：   Ctrl + Y   Copy Line Down（快速拷贝一行）:   Shift + Alt + ↓","categories":["note"]},{"title":"Webstorm","url":"/2019/09/20/webstorm.html","content":"设置中文字体   Show only monospaced fonts 取消打钩   Font：consolas   Size：14   Line spacing: 1.2   Fallback font：Microsoft YaHei   格式化代码快捷键：   Ctrl + Alt + L   键盘快捷键：   Add Or Remove Caret（多光标）:   Alt+ Button1 Click   Redo（反撤销）:   Ctrl + Shift + Z   Expand Live Template / Emmet Abbreviation（展开标签）:   Tab   Fix ESLint Problems（修复ESLint错误）:   Alt + Shift + L   花括号和中括号之间加上空格配置：   Setting &gt; Editor &gt; Code Style &gt; JavaScript &gt; Space,  找到 Within，勾选以下几项并打上勾：   Object literal braces   ES6 import/export braces   Array brackets   Interpolation expressions   配置ESlint   Setting &gt; Plugins，安装ESlint插件   Setting &gt; ESLint Settings，配置   Setting 搜索ESLint，或者查找 Setting &gt; Languages &amp; Frameworks &gt; JavaScript &gt; Code Quality Tools &gt; ESLint   取消webstorm自动保存   第一步：   Settings &gt; Appearance &amp; Behavior &gt; System Settings&gt; Synchronization   &gt; Synchroniza files on frame or editor tab activation           // 激活当前窗口时保存   &gt; Save files on frame deactivation                                       // 切换到其他窗口时保存   &gt; Save files automatically if application is idle for  15 sec.    // 设定一个时间自动保存   &gt; Use &quot;safe write&quot; (save changes to a temporary file first)    // 安全写入,这个选项会不停的保存源文件,因此关闭最后一个就好   第二步：   Settings &gt; Editor &gt; General &gt; Editor Tabs&gt; Appearance   &gt; Mark modified(*)   // 被修改的文件会出现 * 号（在文件图标右下角）","categories":["note"]}]